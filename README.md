# The IJ Interpreter

> âš ï¸ **DISCLAIMER: EXPERIMENTAL SOFTWARE AHEAD** âš ï¸
>
> This is a highly experimental language and interpreter, created as a proof-of-concept that somehow evolved into a working (sort of) system. It's like Frankenstein's monster, but instead of body parts, it's made of duct tape, bubble gum, and questionable design decisions.
>
> The transpilation feature? It's basically magic that we don't fully understand ourselves. The interpreter? It's like a house of cards - it works until it doesn't. Quality and correctness were sacrificed at the altar of "it compiles, ship it!"
>
> **TL;DR:** This is not production-ready software. In fact, it's not even "ready" software. It's more like "we got it to work once and we're not touching it again" software. Please, for the love of all things holy, don't use this in any real project. We're not responsible for any existential crises that might occur from trying to debug this code.
>
> You've been warned! ðŸš§

> ðŸŽ® **FYI: The Making Of This Madness**
>
> This entire project is the result of a series of hacking sessions during a vacation break, created purely for the sake of it. The journey went something like this:
>
> 1. Started with a JavaScript-based LL(1) interpreter, born from a vibe programming session with Cursor IDE and Claude 3.7
> 2. Ported that to a Java-based interpreter (because why not?)
> 3. Created the IJ language implementation of the interpreter as a semi-automated port of the Java version
> 4. Used some custom transpilation tools backed by ChatGPT 4.1 APIs to generate the initial IJ code
>    - Side note: As of May 2025, LLMs are still terrible at writing code in languages not present in their training set
> 5. Created a Golang runtime so that transpilation from IJ to Golang could happen in one pass
> 6. Used the Java-based interpreter as the runtime for the first transpilation of the IJ interpreter to Golang with capabilities implemented in the IJ interpreter itself
> 7. Finally got a native interpreter that could bootstrap itself, making the Java version obsolete
>
> It's like a game of telephone, but with programming languages. Each port probably introduced new bugs and quirks, but hey, that's part of the fun! ðŸŽ²

## Overview

The IJ interpreter is written in the IJ language itself and the native IJ interpreter is generated by the IJ interpreter's Golang transpilation feature (so the binary has been generated by itself - the chicken and egg problem was solved by another temporary IJ language interpreter implementation).

## The IJ Language Grammar (EBNF)

The following EBNF (Extended Backus-Naur Form) grammar defines the syntax of IJ scripts:

```ebnf
/* Program structure */
Program             ::= Statement*

/* Statements */
Statement           ::= VariableDeclaration
                      | FunctionDeclaration
                      | IfStatement
                      | WhileStatement
                      | ReturnStatement
                      | BlockStatement
                      | AssignmentStatement
                      | IndexAssignmentStatement
                      | ExpressionStatement

/* Declarations */
VariableDeclaration ::= "let" Identifier "=" Expression (";" | <newline>)?
FunctionDeclaration ::= "def" Identifier "(" Parameters? ")" BlockStatement
Parameters          ::= Identifier ("," Identifier)*

/* Control flow */
IfStatement         ::= "if" "(" Expression ")" BlockStatement
                       ("else" (BlockStatement))?
WhileStatement      ::= "while" "(" Expression ")" BlockStatement
ReturnStatement     ::= "return" Expression? (";" | <newline>)?

/* Blocks and Assignments */
BlockStatement           ::= "{" Statement* "}"
AssignmentStatement      ::= Identifier "=" Expression (";" | <newline>)?
IndexAssignmentStatement ::= Identifier "[" Expression "]" "=" Expression (";" | <newline>)?
ExpressionStatement      ::= Expression (";" | <newline>)?

/* Expressions */
Expression               ::= OrExpression
OrExpression             ::= AndExpression ("||" AndExpression)*
AndExpression            ::= EqualityExpression ("&&" EqualityExpression)*
EqualityExpression       ::= ComparisonExpression (("==" | "!=") ComparisonExpression)*
ComparisonExpression     ::= AdditiveExpression (("<" | ">" | "<=" | ">=") AdditiveExpression)*
AdditiveExpression       ::= MultiplicativeExpression (("+" | "-") MultiplicativeExpression)*
MultiplicativeExpression ::= PrefixExpression (("*" | "/" | "%") PrefixExpression)*
PrefixExpression         ::= ("-" | "!") PrefixExpression | CallExpression
CallExpression           ::= IndexExpression ("(" Arguments? ")")*
IndexExpression          ::= PrimaryExpression ("[" Expression "]")*
Arguments                ::= Expression ("," Expression)*
PrimaryExpression        ::= Identifier 
                            | NumberLiteral 
                            | StringLiteral
                            | BooleanLiteral
                            | NullLiteral
                            | ArrayLiteral
                            | MapLiteral
                            | "(" Expression ")"

/* Literals and Identifiers */
Identifier         ::= [a-zA-Z_][a-zA-Z0-9_]*
NumberLiteral      ::= [0-9]+ ("." [0-9]+)?
StringLiteral      ::= '"' [^"\n]* '"'
                      | "'" [^'\n]* "'"
BooleanLiteral     ::= "true" | "false"
NullLiteral        ::= "null"
ArrayLiteral       ::= "[" (Expression ("," Expression)*)? "]"
MapLiteral         ::= "{" (MapEntry ("," MapEntry)*)? "}"
MapEntry           ::= Expression ":" Expression

/* Comments */
Comment            ::= SingleLineComment | MultiLineComment
SingleLineComment  ::= "//" [^\n]*
MultiLineComment   ::= "/*" .* "*/"
```

## IJ Language Samples

### Simple Calculator

```ij
// A simple calculator with basic operations
def calculate(a, b, operation) {
  if (operation == "+") {
    return a + b;
  } else {
    if (operation == "-") {
      return a - b;
    } else {
      if (operation == "*") {
        return a * b;
      } else {
        if (operation == "/") {
          if (b == 0) {
            return "Error: Division by zero";
          }
          return a / b;
        } else {
          return "Error: Unknown operation";
        }
      }
    }
  }
}

// Test different operations
puts(calculate(15, 5, "+"));  // Output: 20
puts(calculate(15, 5, "-"));  // Output: 10
puts(calculate(15, 5, "*"));  // Output: 75
puts(calculate(15, 5, "/"));  // Output: 3
puts(calculate(15, 0, "/"));  // Output: Error: Division by zero
```

### Array Sorting

```ij
// Simple bubble sort implementation
def bubbleSort(arr) {
  let n = len(arr);
  let i = 0;
  
  while (i < n) {
    let j = 0;
    let swapped = false;
    
    while (j < n - i - 1) {
      if (arr[j] > arr[j + 1]) {
        // Swap elements
        let temp = arr[j];
        arr[j] = arr[j + 1];
        let jPlusOne = j + 1;
        arr[jPlusOne] = temp;
        swapped = true;
      }
      j = j + 1;
    }
    
    // If no swapping occurred in this pass, array is sorted
    if (!swapped) {
      return arr;
    }
    
    i = i + 1;
  }
  
  return arr;
}

// Test the bubble sort
let numbers = [64, 34, 25, 12, 22, 11, 90];
bubbleSort(numbers);

// Print sorted array
let i = 0;
let output = "Sorted array: ";
while (i < len(numbers)) {
  output = output + numbers[i];
  if (i < len(numbers) - 1) {
    output = output + ", ";
  }
  i = i + 1;
}
puts(output);  // Output: Sorted array: 11, 12, 22, 25, 34, 64, 90
```

### Functional Programming

```ij
// Map function: apply a function to each element in an array
def map(arr, fn) {
  let result = [];
  let i = 0;
  while (i < len(arr)) {
    push(result, fn(arr[i]));
    i = i + 1;
  }
  return result;
}

// Filter function: select elements that satisfy a predicate
def filter(arr, predicate) {
  let result = [];
  let i = 0;
  while (i < len(arr)) {
    if (predicate(arr[i])) {
      push(result, arr[i]);
    }
    i = i + 1;
  }
  return result;
}

// Reduce function: combine elements into a single value
def reduce(arr, fn, initial) {
  let result = initial;
  let i = 0;
  while (i < len(arr)) {
    result = fn(result, arr[i]);
    i = i + 1;
  }
  return result;
}

// Test data
let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Double each number with map
def double(x) { return x * 2; }
let doubled = map(numbers, double);
puts("Doubled: " + doubled[0] + ", " + doubled[1] + ", " + doubled[2] + "...");  
// Output: Doubled: 2, 4, 6...

// Get even numbers with filter
def isEven(x) { return x % 2 == 0; }
let evens = filter(numbers, isEven);
puts("Evens: " + evens[0] + ", " + evens[1] + ", " + evens[2] + "...");  
// Output: Evens: 2, 4, 6...

// Sum all numbers with reduce
def add(acc, x) { return acc + x; }
let sum = reduce(numbers, add, 0);
puts("Sum: " + sum);  // Output: Sum: 55

// Chain operations: Sum of doubled even numbers
let result = reduce(
  map(
    filter(numbers, isEven),
    double
  ),
  add,
  0
);
puts("Sum of doubled evens: " + result);  // Output: Sum of doubled evens: 60
```

### Closures

```ij
def createCounter() {
  let count = 0;
  def counter() {
    count = count + 1;
    return count;
  }
  return counter;
}

let counter = createCounter();
let counter2 = createCounter();

puts(counter()); // Outputs: 1
puts(counter2()); // Outputs: 1

puts(counter()); // Outputs: 2
puts(counter()); // Outputs: 3

puts(counter2()); // Outputs: 2
puts(counter2()); // Outputs: 3
```

### Tests

See also ```tests.s``` for more samples...

```bash
echo|./native_interpreter.sh test.s
```

## How to Run IJ Scripts

All the samples require a MacOS (Arm64) environment because the native interpreter is a platform-specific binary. However, you can generate binaries for other platforms and architectures too.

### Running Scripts

#### One Liners

```bash
echo "puts(22/7.0)"|./interpreter_mac_arm64
```

The IJ interpreter accepts the script source code from SYSIN, so you need to utilize the wrapper scripts for multiline input and scripts that perform I/O (reading lines from SYSIN and writing lines to SYSOUT). If you run a script that does not expect input to read with ```gets()```, you need to make sure the wrapper script doesn't wait for input:

```bash
echo|./native_interpreter.sh foo_not_expecting_input.s
```

#### Sample Script

```ij
puts('What is your name (Ctrl-D to exit)?');
let name = gets();
while (name != null) {
    puts("Hello " + name);
    name = gets();
}
```

### Sample: Run Native Interpreter

Runs the sample script with the native interpreter (```interpreter_mac_arm64```):

```bash
./native_interpreter.sh sample.s
```

### Sample: Run IJ-based Interpreter

Run the sample script with the interpreter (```interpreter.s```) which is executed by the native interpreter (```interpreter_mac_arm64```):

```bash
./interpreter.sh sample.s
```

### Sample: Run Self-Hosted Interpreter

Run the sample script with the interpreter (```interpreter.s```) which is executed by the interpreter (```interpreter.s```) which is executed by the native interpreter (```interpreter_mac_arm64```). Grab a coffee, bootstrapping will take a very long time (minutes, not seconds).

```bash
./selfhosted_interpreter.sh sample.s
```

### Sample: Transpile IJ Code to Golang

Transpile the sample script to Golang sources, build the Golang sources and run the created binary. This requires you to have Go installed and the ```go``` executable in your path.

```bash
./compile.sh sample.s sample   
./sample
```

### Sample: Re-create the Native Interpreter

Transpile the interpreter itself (```interpreter.s```) to Golang sources, build the Golang sources and replace the native interpreter binary (```interpreter_mac_arm64```) with the generated one. This requires you to have Go installed and the ```go``` executable in your path (do it twice).

```bash
./compile.sh interpreter.s interpreter_mac_arm64
./compile.sh interpreter.s interpreter_mac_arm64
```

