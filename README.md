The IJ interpreter

The IJ interpreter is written in the IJ language itself and the native IJ interpreter is generated by the IJ interpreter's golang transpilation feature (so the binary has been generated by itself - the chickend and agg problem was solved by another temporary IJ language interpeter implementation).

The IJ language grammar (EBNF)

The following EBNF (Extended Backus-Naur Form) grammar defines the syntax of IJ scripts:

```ebnf
/* Program structure */
Program             ::= Statement*

/* Statements */
Statement           ::= VariableDeclaration
                      | FunctionDeclaration
                      | IfStatement
                      | WhileStatement
                      | ReturnStatement
                      | BlockStatement
                      | AssignmentStatement
                      | IndexAssignmentStatement
                      | ExpressionStatement

/* Declarations */
VariableDeclaration ::= "let" Identifier "=" Expression (";" | <newline>)?
FunctionDeclaration ::= "def" Identifier "(" Parameters? ")" BlockStatement
Parameters          ::= Identifier ("," Identifier)*

/* Control flow */
IfStatement         ::= "if" "(" Expression ")" BlockStatement
                       ("else" (BlockStatement))?
WhileStatement      ::= "while" "(" Expression ")" BlockStatement
ReturnStatement     ::= "return" Expression? (";" | <newline>)?

/* Blocks and Assignments */
BlockStatement           ::= "{" Statement* "}"
AssignmentStatement      ::= Identifier "=" Expression (";" | <newline>)?
IndexAssignmentStatement ::= Identifier "[" Expression "]" "=" Expression (";" | <newline>)?
ExpressionStatement      ::= Expression (";" | <newline>)?

/* Expressions */
Expression               ::= OrExpression
OrExpression             ::= AndExpression ("||" AndExpression)*
AndExpression            ::= EqualityExpression ("&&" EqualityExpression)*
EqualityExpression       ::= ComparisonExpression (("==" | "!=") ComparisonExpression)*
ComparisonExpression     ::= AdditiveExpression (("<" | ">" | "<=" | ">=") AdditiveExpression)*
AdditiveExpression       ::= MultiplicativeExpression (("+" | "-") MultiplicativeExpression)*
MultiplicativeExpression ::= PrefixExpression (("*" | "/" | "%") PrefixExpression)*
PrefixExpression         ::= ("-" | "!") PrefixExpression | CallExpression
CallExpression           ::= IndexExpression ("(" Arguments? ")")*
IndexExpression          ::= PrimaryExpression ("[" Expression "]")*
Arguments                ::= Expression ("," Expression)*
PrimaryExpression        ::= Identifier 
                            | NumberLiteral 
                            | StringLiteral
                            | BooleanLiteral
                            | NullLiteral
                            | ArrayLiteral
                            | MapLiteral
                            | "(" Expression ")"

/* Literals and Identifiers */
Identifier         ::= [a-zA-Z_][a-zA-Z0-9_]*
NumberLiteral      ::= [0-9]+ ("." [0-9]+)?
StringLiteral      ::= '"' [^"\n]* '"'
                      | "'" [^'\n]* "'"
BooleanLiteral     ::= "true" | "false"
NullLiteral        ::= "null"
ArrayLiteral       ::= "[" (Expression ("," Expression)*)? "]"
MapLiteral         ::= "{" (MapEntry ("," MapEntry)*)? "}"
MapEntry           ::= Expression ":" Expression

/* Comments */
Comment            ::= SingleLineComment | MultiLineComment
SingleLineComment  ::= "//" [^\n]*
MultiLineComment   ::= "/*" .* "*/"
```

IJ language samples

Simple Calculator

```
// A simple calculator with basic operations
def calculate(a, b, operation) {
  if (operation == "+") {
    return a + b;
  } else {
    if (operation == "-") {
      return a - b;
    } else {
      if (operation == "*") {
        return a * b;
      } else {
        if (operation == "/") {
          if (b == 0) {
            return "Error: Division by zero";
          }
          return a / b;
        } else {
          return "Error: Unknown operation";
        }
      }
    }
  }
}

// Test different operations
puts(calculate(15, 5, "+"));  // Output: 20
puts(calculate(15, 5, "-"));  // Output: 10
puts(calculate(15, 5, "*"));  // Output: 75
puts(calculate(15, 5, "/"));  // Output: 3
puts(calculate(15, 0, "/"));  // Output: Error: Division by zero
```

Array Sorting

```
// Simple bubble sort implementation
def bubbleSort(arr) {
  let n = len(arr);
  let i = 0;
  
  while (i < n) {
    let j = 0;
    let swapped = false;
    
    while (j < n - i - 1) {
      if (arr[j] > arr[j + 1]) {
        // Swap elements
        let temp = arr[j];
        arr[j] = arr[j + 1];
        //arr[j + 1] = temp; // FIXME not yet supported
        let jPlusOne = j + 1;
        arr[jPlusOne] = temp;
        swapped = true;
      }
      j = j + 1;
    }
    
    // If no swapping occurred in this pass, array is sorted
    if (!swapped) {
      return arr;
    }
    
    i = i + 1;
  }
  
  return arr;
}

// Test the bubble sort
let numbers = [64, 34, 25, 12, 22, 11, 90];
bubbleSort(numbers);

// Print sorted array
let i = 0;
let output = "Sorted array: ";
while (i < len(numbers)) {
  output = output + numbers[i];
  if (i < len(numbers) - 1) {
    output = output + ", ";
  }
  i = i + 1;
}
puts(output);  // Output: Sorted array: 11, 12, 22, 25, 34, 64, 90
```

Functional Programming

```
// Map function: apply a function to each element in an array
def map(arr, fn) {
  let result = [];
  let i = 0;
  while (i < len(arr)) {
    push(result, fn(arr[i]));
    i = i + 1;
  }
  return result;
}

// Filter function: select elements that satisfy a predicate
def filter(arr, predicate) {
  let result = [];
  let i = 0;
  while (i < len(arr)) {
    if (predicate(arr[i])) {
      push(result, arr[i]);
    }
    i = i + 1;
  }
  return result;
}

// Reduce function: combine elements into a single value
def reduce(arr, fn, initial) {
  let result = initial;
  let i = 0;
  while (i < len(arr)) {
    result = fn(result, arr[i]);
    i = i + 1;
  }
  return result;
}

// Test data
let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Double each number with map
def double(x) { return x * 2; }
let doubled = map(numbers, double);
puts("Doubled: " + doubled[0] + ", " + doubled[1] + ", " + doubled[2] + "...");  
// Output: Doubled: 2, 4, 6...

// Get even numbers with filter
def isEven(x) { return x % 2 == 0; }
let evens = filter(numbers, isEven);
puts("Evens: " + evens[0] + ", " + evens[1] + ", " + evens[2] + "...");  
// Output: Evens: 2, 4, 6...

// Sum all numbers with reduce
def add(acc, x) { return acc + x; }
let sum = reduce(numbers, add, 0);
puts("Sum: " + sum);  // Output: Sum: 55

// Chain operations: Sum of doubled even numbers
let result = reduce(
  map(
    filter(numbers, isEven),
    double
  ),
  add,
  0
);
puts("Sum of doubled evens: " + result);  // Output: Sum of doubled evens: 60
```

Howto run IJ scripts

All the samples require a MacOS (Arm64) environment because the native interpreter is a platform specific binary. But you can generate binaries for other platforms and architectures too.

The IJ interpreter accepts the script source code from SYSIN, so you need to utilize the wrapper scripts for multiline input and input that performs IO (reading linea from SYSIN and writing lines to SYSOUT).

Sample: Run one liners

````
echo "puts(22/7.0)"|./interpreter_mac_arm64
```

Sample: Run script that does not expect input from SYSIN (otherwise you need to hit Ctrl-D)

```
echo|./native_interpreter.sh <script file name>
```

Sample: Run the sample script with the native interpreter (```interpreter_mac_arm64```):

```
./native_interpreter.sh sample.s
```

Sample: Run the sample script with the interpreter (```interpreter.s```) which is executed by the native interpreter (```interpreter_mac_arm64```):

```
./interpreter.sh sample.s
```

Sample: Run the sample script with the interpreter (```interpreter.s```) which is executed by the interpreter (```interpreter.s```) which is executed by the native interpreter (```interpreter_mac_arm64```). Grab a coffe, bootstrapping wil take a very long time (minutes, not seconds).

```
./selfhosted_interpreter.sh sample.s
```

Sample: Transpile the sample script to golang sources, build the golang sources and run the created binary. This requies you have go installed and the the ```go``` executable is in the path.

```
./compile.sh sample.s sample   
./sample
```

Sample: Transpile the interpreter itself (```interpreter.s```) to golang sources, build the golang sources and replace the native interpreter binary (```interpreter_mac_arm64```) with the generated one. This requies you have go installed and the the ```go``` executable is in the path.

```
./compile.sh interpreter.s interpreter_mac_arm64
```

