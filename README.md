# The IJ Interpreter

> âš ï¸ **DISCLAIMER: EXPERIMENTAL SOFTWARE AHEAD** âš ï¸
>
> This is a highly experimental language and interpreter, created as a proof-of-concept that somehow evolved into a working (sort of) system. It's like Frankenstein's monster, but instead of body parts, it's made of duct tape, bubble gum, and questionable design decisions.
>
> The transpilation feature? It's basically magic that we don't fully understand ourselves. The interpreter? It's like a house of cards - it works until it doesn't. Quality and correctness were sacrificed at the altar of "it compiles, ship it!"
>
> **TL;DR:** This is not production-ready software. In fact, it's not even "ready" software. It's more like "we got it to work once and we're not touching it again" software. Please, for the love of all things holy, don't use this in any real project. We're not responsible for any existential crises that might occur from trying to debug this code.
>
> You've been warned! ðŸš§

> ðŸŽ® **FYI: The Making Of This Madness**
>
> This entire project is the result of a series of hacking sessions during a vacation break, created purely for the sake of it. The journey went something like this:
>
> 1. Started with a JavaScript-based LL(1) interpreter, born from a vibe programming session with Cursor IDE and Claude 3.7
> 2. Ported that to a Java-based interpreter (because why not?)
> 3. Created the IJ language implementation of the interpreter as a semi-automated port of the Java version
> 4. Used some custom transpilation tools backed by ChatGPT 4.1 APIs to generate the initial IJ code
>    - Side note: As of May 2025, LLMs are still terrible at writing code in languages not present in their training set
> 5. Created a Golang runtime so that transpilation from IJ to Golang could happen in one pass
> 6. Used the Java-based interpreter as the runtime for the first transpilation of the IJ interpreter to Golang with capabilities implemented in the IJ interpreter itself
> 7. Finally got a native interpreter that could bootstrap itself, making the Java version obsolete
> 8. Cursor and Claude came up with an MCP server implementation, enabling LLMs to evaluate IJ scripts via a protocol.
> 9. Leveraged jules.google.com to automatically fix performance issues in the interpreter and runtime.
> 10. Used claude-4-opus-thinking to waste $50 on attempts to improve performance (with mixed results).
>
> It's like a game of telephone, but with programming languages. Each port probably introduced new bugs and quirks, but hey, that's part of the fun! ðŸŽ²

## Overview

The IJ interpreter is written in the IJ language itself and the native IJ interpreter is generated by the IJ interpreter's Golang transpilation feature (so the binary has been generated by itself â€“ solving the classic "chicken and egg" problem of self-hosting interpreters, where the interpreter is capable of building itself from its own source code).

## Quick Start

The recommended way to run IJ scripts is via the `native_interpreter.sh` script, which automatically selects the correct native binary for your platform (macOS/arm64 or Linux/amd64):

```bash
# Simple one-liner:
echo "puts(22/7.0)" | ./native_interpreter.sh

# Run a script file (prevent input blocking for scripts that don't use gets()):
echo|./native_interpreter.sh script.s

# Run a script that expects input:
./native_interpreter.sh script.s
```

## Requirements

- **To run scripts:**
  - macOS (arm64) or Linux (amd64)
  - The corresponding native binary (`interpreter_mac_arm64` or `interpreter_linux_amd64`)
- **To compile IJ code to a native binary:**
  - Go toolchain installed (`go` in your PATH)
- **To create reproducible cross-platform binaries:**
  - Go toolchain installed
  - Docker installed and running

---

## The IJ Language Grammar (EBNF)

The following EBNF (Extended Backus-Naur Form) grammar defines the syntax of IJ scripts:

```ebnf
/* Program structure */
Program             ::= Statement*

/* Statements */
Statement           ::= VariableDeclaration
                      | FunctionDeclaration
                      | IfStatement
                      | WhileStatement
                      | ReturnStatement
                      | BlockStatement
                      | AssignmentStatement
                      | IndexAssignmentStatement
                      | ExpressionStatement

/* Declarations */
VariableDeclaration ::= "let" Identifier "=" Expression (";" | <newline>)?
FunctionDeclaration ::= "def" Identifier "(" Parameters? ")" BlockStatement
Parameters          ::= Identifier ("," Identifier)*

/* Control flow */
IfStatement         ::= "if" "(" Expression ")" BlockStatement
                       ("else" (BlockStatement))?
WhileStatement      ::= "while" "(" Expression ")" BlockStatement
ReturnStatement     ::= "return" Expression? (";" | <newline>)?

/* Blocks and Assignments */
BlockStatement           ::= "{" Statement* "}"
AssignmentStatement      ::= Identifier "=" Expression (";" | <newline>)?
IndexAssignmentStatement ::= Identifier "[" Expression "]" "=" Expression (";" | <newline>)?
ExpressionStatement      ::= Expression (";" | <newline>)?

/* Expressions */
Expression               ::= OrExpression
OrExpression             ::= AndExpression ("||" AndExpression)*
AndExpression            ::= EqualityExpression ("&&" EqualityExpression)*
EqualityExpression       ::= ComparisonExpression (("==" | "!=") ComparisonExpression)*
ComparisonExpression     ::= AdditiveExpression (("<" | ">" | "<=" | ">=") AdditiveExpression)*
AdditiveExpression       ::= MultiplicativeExpression (("+" | "-") MultiplicativeExpression)*
MultiplicativeExpression ::= PrefixExpression (("*" | "/" | "%") PrefixExpression)*
PrefixExpression         ::= ("-" | "!") PrefixExpression | CallExpression
CallExpression           ::= IndexExpression ("(" Arguments? ")")*
IndexExpression          ::= PrimaryExpression ("[" Expression "]")*
Arguments                ::= Expression ("," Expression)*
PrimaryExpression        ::= Identifier 
                            | NumberLiteral 
                            | StringLiteral
                            | BooleanLiteral
                            | NullLiteral
                            | ArrayLiteral
                            | MapLiteral
                            | "(" Expression ")"

/* Literals and Identifiers */
Identifier         ::= [a-zA-Z_][a-zA-Z0-9_]*
NumberLiteral      ::= [0-9]+ ("." [0-9]+)?
StringLiteral      ::= '"' [^"\n]* '"'
                      | "'" [^'\n]* "'"
BooleanLiteral     ::= "true" | "false"
NullLiteral        ::= "null"
ArrayLiteral       ::= "[" (Expression ("," Expression)*)? "]"
MapLiteral         ::= "{" (MapEntry ("," MapEntry)*)? "}"
MapEntry           ::= Expression ":" Expression

/* Comments */
Comment            ::= SingleLineComment | MultiLineComment
SingleLineComment  ::= "//" [^\n]*
MultiLineComment   ::= "/*" .* "*/"
```

---

## IJ Language Samples

### Simple Calculator

```ij
// A simple calculator with basic operations
def calculate(a, b, operation) {
  if (operation == "+") {
    return a + b;
  } else {
    if (operation == "-") {
      return a - b;
    } else {
      if (operation == "*") {
        return a * b;
      } else {
        if (operation == "/") {
          if (b == 0) {
            return "Error: Division by zero";
          }
          return a / b;
        } else {
          return "Error: Unknown operation";
        }
      }
    }
  }
}

// Test different operations
puts(calculate(15, 5, "+"));  // Output: 20
puts(calculate(15, 5, "-"));  // Output: 10
puts(calculate(15, 5, "*"));  // Output: 75
puts(calculate(15, 5, "/"));  // Output: 3
puts(calculate(15, 0, "/"));  // Output: Error: Division by zero
```

### Array Sorting

```ij
// Simple bubble sort implementation
def bubbleSort(arr) {
  let n = len(arr);
  let i = 0;
  
  while (i < n) {
    let j = 0;
    let swapped = false;
    
    while (j < n - i - 1) {
      if (arr[j] > arr[j + 1]) {
        // Swap elements
        let temp = arr[j];
        arr[j] = arr[j + 1];
        let jPlusOne = j + 1;
        arr[jPlusOne] = temp;
        swapped = true;
      }
      j = j + 1;
    }
    
    // If no swapping occurred in this pass, array is sorted
    if (!swapped) {
      return arr;
    }
    
    i = i + 1;
  }
  
  return arr;
}

// Test the bubble sort
let numbers = [64, 34, 25, 12, 22, 11, 90];
bubbleSort(numbers);

// Print sorted array
let i = 0;
let output = "Sorted array: ";
while (i < len(numbers)) {
  output = output + numbers[i];
  if (i < len(numbers) - 1) {
    output = output + ", ";
  }
  i = i + 1;
}
puts(output);  // Output: Sorted array: 11, 12, 22, 25, 34, 64, 90
```

### Functional Programming

```ij
// Map function: apply a function to each element in an array
def map(arr, fn) {
  let result = [];
  let i = 0;
  while (i < len(arr)) {
    push(result, fn(arr[i]));
    i = i + 1;
  }
  return result;
}

// Filter function: select elements that satisfy a predicate
def filter(arr, predicate) {
  let result = [];
  let i = 0;
  while (i < len(arr)) {
    if (predicate(arr[i])) {
      push(result, arr[i]);
    }
    i = i + 1;
  }
  return result;
}

// Reduce function: combine elements into a single value
def reduce(arr, fn, initial) {
  let result = initial;
  let i = 0;
  while (i < len(arr)) {
    result = fn(result, arr[i]);
    i = i + 1;
  }
  return result;
}

// Test data
let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

// Double each number with map
def double(x) { return x * 2; }
let doubled = map(numbers, double);
puts("Doubled: " + doubled[0] + ", " + doubled[1] + ", " + doubled[2] + "...");  
// Output: Doubled: 2, 4, 6...

// Get even numbers with filter
def isEven(x) { return x % 2 == 0; }
let evens = filter(numbers, isEven);
puts("Evens: " + evens[0] + ", " + evens[1] + ", " + evens[2] + "...");  
// Output: Evens: 2, 4, 6...

// Sum all numbers with reduce
def add(acc, x) { return acc + x; }
let sum = reduce(numbers, add, 0);
puts("Sum: " + sum);  // Output: Sum: 55

// Chain operations: Sum of doubled even numbers
let result = reduce(
  map(
    filter(numbers, isEven),
    double
  ),
  add,
  0
);
puts("Sum of doubled evens: " + result);  // Output: Sum of doubled evens: 60
```

### Closures

```ij
def createCounter() {
  let count = 0;
  def counter() {
    count = count + 1;
    return count;
  }
  return counter;
}

let counter = createCounter();
let counter2 = createCounter();

puts(counter()); // Outputs: 1
puts(counter2()); // Outputs: 1

puts(counter()); // Outputs: 2
puts(counter()); // Outputs: 3

puts(counter2()); // Outputs: 2
puts(counter2()); // Outputs: 3
```

---

## Running IJ Scripts

The IJ interpreter accepts script source code from STDIN. Native binaries are provided for macOS (arm64) and Linux (amd64), with the `native_interpreter.sh` script automatically selecting the correct binary for your platform.

### Basic Execution Methods

```bash
# Native interpreter (fastest, recommended)
./native_interpreter.sh sample.s

# IJ-based interpreter (runs interpreter.s via native interpreter)
./interpreter.sh sample.s

# Self-hosted interpreter (very slow, runs interpreter in itself)
./selfhosted_interpreter.sh sample.s
```

**Note:** For scripts that don't expect input via `gets()`, use `echo|` to prevent input blocking:
```bash
echo|./native_interpreter.sh script_without_input.s
```

---

## Building & Compilation

### Complete Build (All Platforms)

Re-creates all binaries (interpreter and MCP server) for all supported platforms. Requires Go and Docker:

```bash
./build.sh
```

### Quick Build (Current Platform)

Transpiles IJ to Go and builds a native binary for your current platform. Requires Go toolchain:

```bash
./compile.sh sample.s sample_binary
./sample_binary
```

### Reproducible Cross-Platform Builds

Creates reproducible binaries for specific platforms using Docker:

```bash
# For macOS/arm64:
./compile-mac.sh sample.s sample_mac_arm64

# For Linux/amd64:
./compile-linux.sh sample.s sample_linux_amd64
```

### Rebuilding the Native Interpreter

To regenerate the provided native interpreter binaries:

```bash
./compile-mac.sh interpreter.s interpreter_mac_arm64
./compile-linux.sh interpreter.s interpreter_linux_amd64
```

---

## Tests

Run the comprehensive test suite:

```bash
./test.sh
# or
echo|./native_interpreter.sh test.s
```

The test suite covers arithmetic, variables, control flow, functions, closures, arrays, maps, strings, type checks, and more.

---

## MCP Server (Model Control Protocol)

The MCP server allows LLMs (such as Claude Desktop) to evaluate IJ scripts via a JSON-RPC protocol.

### Running the MCP Server

```bash
./mcp.sh           # Interpreted mode (builds and runs via interpreter)
./native_mcp.sh    # Native mode (runs pre-built binary)
```

### Claude Desktop Configuration

```json
{
  "mcpServers": {
    "ijscript": {
      "command": "/.../interpreter-ij/mcp_mac_arm64",
      "args": [],
      "transport": {
        "type": "stdio"
      }
    }
  }
}
```

---

## Shell Scripts Reference

| Script                    | Description                                                                                   |
|--------------------------|-----------------------------------------------------------------------------------------------|
| `build.sh`               | Re-creates all binaries (interpreter and MCP server) for all supported platforms. Requires Go and Docker. Also runs tests. |
| `compile.sh`             | Transpiles IJ to Go and builds a native binary for your current platform.                      |
| `compile-mac.sh`         | Cross-compiles a reproducible binary for macOS/arm64 using Docker.                             |
| `compile-linux.sh`       | Cross-compiles a reproducible binary for Linux/amd64 using Docker.                             |
| `native_interpreter.sh`  | Runs the correct native interpreter for your platform.                                         |
| `interpreter.sh`         | Runs the interpreter implemented in IJ, using the native interpreter.                         |
| `selfhosted_interpreter.sh` | Bootstraps the interpreter by running the interpreter in itself.                              |
| `test.sh`                | Runs the test suite.                                                                           |
| `mcp.sh`                 | Builds and runs the MCP server in interpreted mode.                                            |
| `native_mcp.sh`          | Runs the native MCP server for your platform.                                                  |
| `until.rb`               | Helper for waiting for a string in output (used in build scripts).                             |

---

## AI-Assisted Development with Claude

This project would not exist without extensive help from LLMs like Claude and ChatGPT. Their contributions included:

- Initial language porting across JavaScript, Java, IJ, and Golang
- Transpiler generation and debugging
- Performance tuning and optimization attempts
- Self-hosting strategies and bootstrapping logic
- MCP server design and implementation
- Automated bug fixing and code improvements

It stands as a testament to collaborative development between human ingenuity and machine intelligence, demonstrating both the potential and current limitations of AI-assisted programming, especially when working with languages not present in LLM training sets.